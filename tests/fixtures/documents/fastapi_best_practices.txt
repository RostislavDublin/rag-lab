# Python FastAPI Best Practices

## Project Structure

### Recommended Layout
```
project/
├── src/
│   ├── __init__.py
│   ├── main.py              # FastAPI app
│   ├── config.py            # Settings
│   ├── models/              # Pydantic models
│   ├── routers/             # API routes
│   ├── services/            # Business logic
│   ├── database.py          # Database connection
│   └── dependencies.py      # Dependency injection
├── tests/
├── requirements.txt
└── README.md
```

## Application Initialization

### Basic App Setup
```python
from fastapi import FastAPI
from contextlib import asynccontextmanager

@asynccontextmanager
async def lifespan(app: FastAPI):
    # Startup: initialize resources
    print("Starting up...")
    db.connect()
    yield
    # Shutdown: cleanup resources
    print("Shutting down...")
    db.disconnect()

app = FastAPI(
    title="My API",
    version="1.0.0",
    lifespan=lifespan
)
```

## Request Validation

### Pydantic Models
```python
from pydantic import BaseModel, Field, validator

class DocumentUpload(BaseModel):
    title: str = Field(..., min_length=1, max_length=200)
    content: str = Field(..., min_length=10)
    tags: list[str] = Field(default_factory=list)
    
    @validator('tags')
    def validate_tags(cls, v):
        if len(v) > 10:
            raise ValueError('Maximum 10 tags allowed')
        return v
```

## Error Handling

### Custom Exception Handlers
```python
from fastapi import HTTPException, Request
from fastapi.responses import JSONResponse

class DocumentNotFoundError(Exception):
    pass

@app.exception_handler(DocumentNotFoundError)
async def document_not_found_handler(
    request: Request, 
    exc: DocumentNotFoundError
):
    return JSONResponse(
        status_code=404,
        content={"error": "Document not found"}
    )
```

## Dependency Injection

### Database Dependencies
```python
from fastapi import Depends

async def get_db():
    db = Database()
    try:
        yield db
    finally:
        await db.close()

@app.get("/users/{user_id}")
async def get_user(
    user_id: int,
    db: Database = Depends(get_db)
):
    return await db.get_user(user_id)
```

## Background Tasks

### Long-Running Operations
```python
from fastapi import BackgroundTasks

def process_document(doc_id: str):
    # Heavy processing
    time.sleep(10)
    print(f"Processed {doc_id}")

@app.post("/documents")
async def create_document(
    background_tasks: BackgroundTasks
):
    doc_id = generate_id()
    background_tasks.add_task(process_document, doc_id)
    return {"id": doc_id, "status": "processing"}
```

## File Uploads

### Handling Files
```python
from fastapi import UploadFile, File

@app.post("/upload")
async def upload_file(
    file: UploadFile = File(...)
):
    # Validate size
    if file.size > 10_000_000:  # 10MB
        raise HTTPException(400, "File too large")
    
    # Read content
    content = await file.read()
    
    # Process...
    return {"filename": file.filename}
```

## Testing

### Using TestClient
```python
from fastapi.testclient import TestClient

client = TestClient(app)

def test_health():
    response = client.get("/health")
    assert response.status_code == 200
    assert response.json() == {"status": "healthy"}

def test_create_user():
    response = client.post(
        "/users",
        json={"name": "John", "email": "john@example.com"}
    )
    assert response.status_code == 201
```

## Performance Optimization

### Caching
```python
from functools import lru_cache

@lru_cache()
def get_settings():
    return Settings()

@app.get("/config")
async def get_config(
    settings: Settings = Depends(get_settings)
):
    return settings
```

### Connection Pooling
Use asyncpg or databases library with connection pools:
```python
import asyncpg

pool = await asyncpg.create_pool(
    dsn=DATABASE_URL,
    min_size=10,
    max_size=20,
    command_timeout=60
)
```

## Security

### API Key Authentication
```python
from fastapi import Security, HTTPException
from fastapi.security import APIKeyHeader

api_key_header = APIKeyHeader(name="X-API-Key")

async def verify_api_key(
    api_key: str = Security(api_key_header)
):
    if api_key != "secret-key":
        raise HTTPException(403, "Invalid API key")
    return api_key
```

### CORS
```python
from fastapi.middleware.cors import CORSMiddleware

app.add_middleware(
    CORSMiddleware,
    allow_origins=["https://example.com"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)
```

## Logging

### Structured Logging
```python
import logging
import json

logging.basicConfig(
    level=logging.INFO,
    format='%(message)s'
)

logger = logging.getLogger(__name__)

@app.get("/users/{user_id}")
async def get_user(user_id: int):
    logger.info(json.dumps({
        "event": "get_user",
        "user_id": user_id,
        "timestamp": datetime.utcnow().isoformat()
    }))
    # ...
```

## Deployment

### Docker
```dockerfile
FROM python:3.11-slim

WORKDIR /app
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY src/ ./src/

CMD ["uvicorn", "src.main:app", "--host", "0.0.0.0", "--port", "8080"]
```

### Environment Variables
Use pydantic-settings for configuration:
```python
from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    database_url: str
    api_key: str
    
    class Config:
        env_file = ".env"
```

## API Documentation

### Customize OpenAPI
```python
app = FastAPI(
    title="My API",
    description="API for document management",
    version="1.0.0",
    docs_url="/docs",
    redoc_url="/redoc",
    openapi_tags=[
        {
            "name": "documents",
            "description": "Document operations"
        }
    ]
)
```

## Common Patterns

### Pagination
```python
from typing import Optional

@app.get("/items")
async def list_items(
    skip: int = 0,
    limit: int = 100
):
    items = db.get_items(skip=skip, limit=limit)
    return {
        "items": items,
        "skip": skip,
        "limit": limit,
        "total": db.count_items()
    }
```

### Rate Limiting
Use slowapi for rate limiting:
```python
from slowapi import Limiter
from slowapi.util import get_remote_address

limiter = Limiter(key_func=get_remote_address)
app.state.limiter = limiter

@app.get("/limited")
@limiter.limit("5/minute")
async def limited_endpoint():
    return {"message": "Rate limited"}
```

## Health Checks

### Comprehensive Health Endpoint
```python
@app.get("/health")
async def health_check():
    checks = {
        "database": await check_database(),
        "storage": await check_storage(),
        "cache": await check_cache()
    }
    
    healthy = all(checks.values())
    status_code = 200 if healthy else 503
    
    return JSONResponse(
        status_code=status_code,
        content={
            "status": "healthy" if healthy else "unhealthy",
            "checks": checks
        }
    )
```
